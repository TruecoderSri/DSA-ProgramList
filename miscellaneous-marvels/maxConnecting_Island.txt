int dfs(int i,int j,vector<vector<int>>&vis,int n,int m,int name,vector<vector<int>>&grid){
        
        // boundary conditions
        if(i<0 ||i>=n||j<0||j>=m ||vis[i][j]==1) return 0;
        
      vis[i][j]=1;
      grid[i][j]=name;
      
      int count=1+dfs(i+1,j,vis,n,m,name,grid)+dfs(i-1,j,vis,n,m,name,grid)+dfs(i,j+1,vis,n,m,name,grid)+dfs(i,j-1,vis,n,m,name,grid);
      return count;
    }
  
    int largestIsland(vector<vector<int>>& grid) 
    {
        // Your code goes here.
        int n=grid.size();
       
        vector<vector<int>> vis(n,vector<int>(n,0));
        int name=2; // gives a name to each of the islandes since 1 already is the ele we're searching
        // store the island name,areaCount in a map
        unordered_map<int,int> mp;
        
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1 && !vis[i][j]){
                 int count=dfs(i,j,vis,n,n,name,grid);
                 mp[name]=count;
                 name++;
                }
            }
        }
        int ans=0;
         for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
             if(grid[i][j]==0){
                 
                int d=(i+1)<n?grid[i+1][j]:0;
                int u=(i-1)>=0?grid[i-1][j]:0;
                int l=(j-1)>=0?grid[i][j-1]:0;
                int r=(j+1)<n?grid[i][j+1]:0;
                
                unordered_set<int> s;
                s.insert(d);s.insert(u);s.insert(l);s.insert(r);
                
                int res=1;
                
                for(auto it:s){
                   if (mp.find(it) != mp.end()) {
        res += mp[it];
     }
                }
                ans=max(ans,res);
             }   
            }
             
         }
         if(ans==0)  return n*n;
         return ans;
        
    }